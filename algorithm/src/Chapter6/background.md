## 背景  

### 事件驱动模拟   

维护一个真实世界的模型并且根据事件控制模型中发生的变化   

#### 刚性球体模型   

* 每个粒子与墙以及相互之间的碰撞是弹性的；
* 每个粒子都是一个已知位置，速度，质量和直径的球体；
* 不存在其他外力；


#### 时间驱动模拟

我们的目的是记录所有粒子在任意时间内的位置和速度。   
有一种解决的办法叫做`时间驱动模拟`在每次更新的时候，我们都需要检查所有粒子对，判定是否可能相遇，然后还原
第一次碰撞。

#### 事件驱动模拟  

重点是关注下一次碰撞，我们需要使用一个优先级队列来记录所有事件。  
事件是未来某个事件的一次潜在的碰撞。每个事件关联的优先级就是他发生的时间。
当从优先级队列删除优先级最低的元素的时候，就会得到下一次潜在的碰撞。


#### 碰撞预测
![](https://algs4.cs.princeton.edu/61event/images/collision-elastic2.png)   

判断粒子和其他物体是否又潜在的碰撞风险，计算碰撞产生的时间，并且按照优先级放入队列，这样时间短的时间会先
从队列中弹出。
##### 特殊情况

在粒子距离另一个粒子太远的情况下，需要使用一个limit的参数来指定有效的时间段。    

#### 排除无效事件   
延时算法:当一个粒子参与了一次碰撞的时候，不删除优先级队列中这个粒子相关的所有碰撞，在从优先级队列中被取出来的时候  
再来处理这次碰撞 
即时算法：立即删除所有相关事件

#### 实现

##### 粒子
* 粒子的位置，速度，半径，质量 
* 粒子和另外粒子碰撞的时间 
* 粒子与水平墙壁碰撞的时间
* 粒子与垂直墙壁碰撞的时间 
* 粒子与物体碰撞后的速度   

##### 事件
* 事件发生的时间  
* 事件的类型

##### 预测粒子碰撞
预测粒子与其他所有粒子将会碰撞的时间   
判断是否在规定的时间内，压入队列   

##### 主循环
* 取出即将发生的事件
* 无效就忽略 
* 按照直线运动轨迹运动到t
* 更新所有参与碰撞的粒子的速度   
* 使用预测方法预测参与碰撞的粒子未来发生的碰撞
压入队列   


### B-树   

* 内部节点:含有与页相关联的页的副本   
* 外部节点:含有指向实际数据的引用   
* 哨兵键:小于其他所有键，一开始B-树只含有   
一个根节点，节点初始化出的就是哨兵节点   

#### 查找和插入    

查找:在可能含有被查找键的唯一子树中进行一次递归的  
搜索   
![](https://img-blog.csdn.net/20170910224108969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjEyNDQzOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
插入:    
如果被插入的节点变成一个溢出的节点   
递归调用不断向上调用分裂溢出的节点   
![](https://img-blog.csdn.net/20170910224922359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjEyNDQzOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

   
### 网络流算法   

流量网络:是一张权重为正的加权有向图   

最大流量算法：网络中初始流量为0,沿着任意  
从起点到终点的增广路径增大流量，直到不存在这样的路径   
